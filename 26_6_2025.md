# ***1800. Maximum Ascending Subarray Sum***

Given an array of positive integers nums, return the maximum possible sum of an strictly increasing subarray in nums.  
A subarray is defined as a contiguous sequence of numbers in an array.

### Example 1:
Input: nums = `[10,20,30,5,10,50] `  
Output: `65`  
Explanation: `[5,10,50]` is the ascending subarray with the maximum sum of 65.  
### Example 2:  
Input: nums = `[12,17,15,13,10,11,12]`  
Output: `33`  
Explanation: `[10,11,12]` is the ascending subarray with the maximum sum of 33.  

### Constraints:

+ `1 <= nums.length <= 100`
+ `1 <= nums[i] <= 100`

## CODE : 
```java
class Solution {
    public int maxAscendingSum(int[] nums) {
        int l=0 , t=0 ;
        int r = 1;
        int max = 0 , ret=0;
        while(r!=nums.length){
            if(nums[t]<nums[r]){
                t++;
                r++;
            }else{
                ret = sum(nums,l,r);
                max = (ret>max) ? ret : max ;
                t=r;
                l=r;
                r++;
            }
        }
        ret = sum(nums,l,r);
        max = (ret>max) ? ret : max ;
        return max;
    }
    static int sum(int[] arr,int l,int n){
        int sum = 0;
        for(int i=l ; i<n ; i++){
            sum+=arr[i];
        }
        return sum;
    }
}
```
### LeetCode : [Submission Status](https://leetcode.com/problems/maximum-ascending-subarray-sum/submissions/1782891058)
-------------------------------------------------------------------------------------------------------------------------------------------------------------
# 1773. Count Items Matching a Rule
You are given an array items, where each items[i] = `[typei, colori, namei]` describes the type, color, and name of the ith item.  
You are also given a rule represented by two strings, ruleKey and ruleValue.  
The ith item is said to match the rule if one of the following is true:
```
ruleKey == "type" and ruleValue == typei.
ruleKey == "color" and ruleValue == colori.
ruleKey == "name" and ruleValue == namei.
```
Return the number of items that match the given rule.

 

### Example 1:
Input: items = `[["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]]`, ruleKey = `"color"`, ruleValue = `"silver"`  
Output: `1`  
Explanation: There is only one item matching the given rule, which is `["computer","silver","lenovo"]`.  
### Example 2:
Input: items = `[["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]]`, ruleKey = `"type"`, ruleValue = `"phone"`  
Output: `2`  
Explanation: There are only two items matching the given rule, which are `["phone","blue","pixel"]` and `["phone","gold","iphone"]`. Note that the item `["computer","silver","phone"]` does not match.

### Constraints:

+`1 <= items.length <= 104`  
+`1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10`  
+`ruleKey is equal to either "type", "color", or "name".`  
+`All strings consist only of lowercase letters.`  


## CODE
```java
class Solution {
    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {
        if(ruleKey.equals("type")){
            return count(items,ruleValue,0);
        }else if(ruleKey.equals("color")){
            return count(items,ruleValue,1);
        }else{
            return count(items,ruleValue,2);
        }
    }
    static int count(List<List<String>> items,String ruleValue,int col){
        String str ;
        int sum = 0;
        for(int i=0 ; i<items.size() ; i++){
            str = items.get(i).get(col) ;
            if(ruleValue.equals(str)) sum++;
        }
        return sum;
    }
}
```

### LeetCode : [Submission Status](https://leetcode.com/problems/count-items-matching-a-rule/submissions/1782980825)
-------------------------------------------------------------------------------------------------------------------------------------------------------------
# 1779. Find Nearest Point That Has the Same X or Y Coordinate
You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each `points[i] = [a <sub>i</sub> , b <sub>i</sub> ]` represents that a point exists at `(a<sub>i</sub>, b<sub>i</sub>)`. A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.  

Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.  

The Manhattan distance between two points (x1, y1) and (x2, y2) is `abs(x1 - x2) + abs(y1 - y2)`.

### Example 1:

Input: x = `3`, y = `4`, points = `[[1,2],[3,1],[2,4],[2,3],[4,4]]`  
Output: `2`  
Explanation: Of all the points, only `[3,1], [2,4] and [4,4] are valid`. Of the valid points, `[2,4] and [4,4]` have the smallest `Manhattan distance` from your current location, with a distance of 1. `[2,4]` has the smallest index, so return `2`.
### Example 2:

Input: x = `3`, y = `4`, points = `[[3,4]]`  
Output: `0`  
Explanation: The answer is allowed to be on the same location as your current location.
### Example 3:

Input: x = `3`, y = `4`, points = `[[2,3]]`  
Output: `-1`  
Explanation: There are no valid points.
 

### Constraints:

+ `1 <= points.length <= 104`
+ `points[i].length == 2`
+ `1 <= x, y, ai, bi <= 104`

## CODE 
```java
class Solution {
    public int nearestValidPoint(int x, int y, int[][] points) {
        int min = Integer.MAX_VALUE , index = -1 ;
        for(int i=0 ; i<points.length ; i++){
            if(x==points[i][0] || y==points[i][1]){
                int tmp = Math.abs(x-points[i][0]) + Math.abs(y-points[i][1]);
                if(tmp<min){
                    min = tmp ;
                    index = i ;
                }
            }
        }
        return index ;
    }
}
```

### LeetCode : [Submission Status](https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/submissions/1783820834)
